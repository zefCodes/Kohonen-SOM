<!DOCTYPE html>
<html>
<head>

</head>

<body>

<h1>Kohonen Self-Organizing Map</h1>
<canvas id =  "drawCanvas" width=600px; height=600px"></canvas>
<p>
<button id = "startstop" type="button" onclick="startstop()"></button>
</p>
<script>

var c=document.getElementById("drawCanvas");
var button = document.getElementById('startstop');
var ctx=c.getContext("2d");
var yLoc = 120;
var xLoc = 100;
var gridSize = 7;
var iterationNumber=0;
var scale = 500;
var transx = 50;
var transy = 50;
var start = false;

var Nodes = [];

function startstop() {
	start^=true;
}

function Node(weightX, weightY, indexI, indexJ, lX, lY){
	this.weightX = weightX;
	this.weightY = weightY;
	this.indexI = indexI;
	this.indexJ = indexJ;
	this.lerpX = lX;
	this.lerpY = lY;
	var neighbours = [];

	this.getWeightX = function(){
		return this.weightX;
	} 
	this.getWeightY = function(){
		return this.weightY;
	} 
	this.getindexI = function(){
		return this.indexI;
	} 
	this.getindexJ = function(){
		return this.indexJ;
	}
	this.pushNeighbour = function(neighbour){
		neighbours.push(neighbour);
	} 	
	this.getNeighbours = function(neighbour){
		return neighbours;
	} 
	this.setWeightX = function(X){
		this.weightX=X;
	} 
	this.setWeightY = function(Y){
		this.weightY=Y;
	} 
	this.calculateLerp = function() {

		this.lerpX+=(this.weightX - this.lerpX)*0.01;
		this.lerpY+=(this.weightY - this.lerpY)*0.01;
	}
	this.getLerpY = function() {
		 return this.lerpY;
	}
	this.getLerpX = function() {
		 return this.lerpX;
	}
}
var randX;
var randY;

function mainLoop() { 
	if (start){
		update();
		button.innerHTML = "Pause";
	} 
	else {
		button.innerHTML = "Start";
	}
	clear();
	draw();
	requestAnimationFrame(mainLoop);
	
}


function clear() {
	ctx.beginPath(); //
	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, 600, 600);
	ctx.stroke();
	ctx.closePath();
}

function generateRandomVector() {
	randX = Math.random();
	randY = Math.random();
}
function calculateBMU() {
	var currentNormSquared = 10000;
	var BMU = 0;
	for (var i=0; i<gridSize*gridSize; i++) {
		var x = randX - Nodes[i].getWeightX();
		var y = randY - Nodes[i].getWeightY();
		normSquared = x*x + y*y;
		
		if (normSquared<currentNormSquared) {
			currentNormSquared = normSquared;
			BMU=i;
		}
		
	}
	console.log("BEST " + BMU);
	return BMU;
}


function alterNodes(i) {
	//console.log(bestNode);
	var lambda = 1/(1+(Math.log(iterationNumber)));
	var gamma = 0.5*lambda;
	var nodeWX = Nodes[i].getWeightX();
	var nodeWY = Nodes[i].getWeightY();
	Nodes[i].setWeightX(nodeWX + lambda*(randX-nodeWX));
	Nodes[i].setWeightY(nodeWY + lambda*(randY-nodeWY));
	
	var neighbours = Nodes[i].getNeighbours();
	for (var i=0; i<neighbours.length; i++) {
		var nodeNeighbourWX = neighbours[i].getWeightX();
		var nodeNeighbourWY = neighbours[i].getWeightY();
		neighbours[i].setWeightX(nodeNeighbourWX + gamma*(randX-nodeNeighbourWX));
		neighbours[i].setWeightY(nodeNeighbourWY + gamma*(randY-nodeNeighbourWY));
	}
}

function update() {
	iterationNumber++;
	generateRandomVector();
	alterNodes(calculateBMU());
}

function initWeights() {

	for (var i=0; i<gridSize; i++) {
		for (var j=0; j<gridSize; j++) {
			var node = new Node(Math.random(), Math.random(), i, j, 0 ,0);
			Nodes.push(node);
		}
	}

}

function isNeighbour(indexI,indexJ,indexI2,indexJ2) {
	if (indexI+1==indexI2 && indexJ==indexJ2 || indexJ+1==indexJ2 && indexI==indexI2|| indexI-1==indexI2 && indexJ==indexJ2 || indexJ-1==indexJ2 && indexI==indexI2) {
		return true;
	}
	else {
		return false;
	}
}

function initNeighbours() {
	for (var i=0; i<gridSize*gridSize; i++) {
		var indexI = Nodes[i].getindexI();
		var indexJ = Nodes[i].getindexJ();
		for (var j=0; j<gridSize*gridSize; j++) {
			var indexI2 = Nodes[j].getindexI();
			var indexJ2 = Nodes[j].getindexJ();
			if (isNeighbour(indexI,indexJ,indexI2,indexJ2)) {
				Nodes[i].pushNeighbour(Nodes[j]);
				//console.log("PUSHING NEIGHBOUR " + Nodes[j].getindexI() + ", " + Nodes[j].getindexJ() + " FOR NODE " + i);
			}
		}
	}
}
function drawLine(stx,sty,endx,endy) {
	ctx.beginPath();
	ctx.moveTo(stx,sty);
	ctx.lineTo(endx,endy);
	ctx.strokeStyle = "red";
	ctx.stroke();
	ctx.closePath();
}
function drawConnections() {
	for(var i=0; i<gridSize*gridSize; i++) {
		var neighbours = Nodes[i].getNeighbours();
		for(var j=0; j<neighbours.length; j++) {
			Nodes[i].calculateLerp();
			neighbours[j].calculateLerp();
			drawLine((Nodes[i].getLerpX()*scale)+transx,(Nodes[i].getLerpY()*scale)+transy,(neighbours[j].getLerpX()*scale)+transx,(neighbours[j].getLerpY()*scale)+transy);
			//console.log(i + " Drawing line between " + Nodes[i].getWeightX()+","+Nodes[i].getWeightY() +" and "+ neighbours[j].getWeightX()+","+neighbours[j].getWeightY());
		}
		//console.log(i + " " + neighbours.length);
	}
	//console.log("complete");
}
function drawPoints() {
	
	for(var i=0; i<gridSize*gridSize; i++) {
	
		Nodes[i].calculateLerp();
		
		ctx.beginPath();
		ctx.arc((Nodes[i].getLerpX()*scale)+transx,(Nodes[i].getLerpY()*scale)+transy,6,0,2*Math.PI);
		ctx.fillStyle = "black";
		ctx.fill();
		ctx.closePath();
		
		ctx.beginPath();
		ctx.arc((Nodes[i].getLerpX()*scale)+transx,(Nodes[i].getLerpY()*scale)+transy,6,0,2*Math.PI);
		ctx.strokeStyle = "red";
		ctx.lineWidth=1;
		ctx.stroke();
		ctx.closePath();		
	}	
}

function drawText() {
	ctx.font = "15px Calibri";
	ctx.fillStyle = "red";
	ctx.fillText("Iteration: " + iterationNumber,20,30);
}

function draw() {
	drawConnections();
	drawPoints();	
	drawText();
}

initWeights();
initNeighbours();
requestAnimationFrame(mainLoop);
</script>

</body>
</html>